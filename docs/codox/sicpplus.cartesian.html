<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>sicpplus.cartesian documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/hyperlegible.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">sicpplus</span> <span class="project-version">0.0.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="README.html"><div class="inner"><span>sicpplus</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 current"><a href="sicpplus.cartesian.html"><div class="inner"><span>sicpplus.cartesian</span></div></a></li><li class="depth-1 "><a href="sicpplus.commons.core.html"><div class="inner"><span>sicpplus.commons.core</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="sicpplus.cartesian.html#var-compose"><div class="inner"><span>compose</span></div></a></li><li class="depth-1"><a href="sicpplus.cartesian.html#var-diagonal"><div class="inner"><span>diagonal</span></div></a></li><li class="depth-1"><a href="sicpplus.cartesian.html#var-parallel-diagonal"><div class="inner"><span>parallel-diagonal</span></div></a></li><li class="depth-1"><a href="sicpplus.cartesian.html#var-parallel-split"><div class="inner"><span>parallel-split</span></div></a></li><li class="depth-1"><a href="sicpplus.cartesian.html#var-projection"><div class="inner"><span>projection</span></div></a></li><li class="depth-1"><a href="sicpplus.cartesian.html#var-split"><div class="inner"><span>split</span></div></a></li><li class="depth-1"><a href="sicpplus.cartesian.html#var-tuple"><div class="inner"><span>tuple</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">sicpplus.cartesian</h1><div class="doc"><div class="markdown"><p>A sketch of cartesian product sets, elements, and functions.</p>
<p>This is intended as an alternate approach to the examples in SDFF section 2.1, which is nominally about “combinators”.</p>
<p>I think that section, and perhaps the idea of ‘combinator’ in general, is unnecessarily complicated by the failure to think clearly about functions, their domains and codomains, and how that relates to functions with multiple arguments and multiple return values.</p>
<p>An alternative is to take all functions as single input, single output. Multiple argument/value calls are considered syntactic sugar (and perhaps compiler hints) for functions whose (co)domains are cartesian product spaces.</p>
<p>With this approach, it seems at this point that (almost all) combinators can be replaced by compositions with domain mappings and tuple constructors.</p>
<p>Some issues to be resolved: </p><ul> <li> I’m taking cartesian products as non-associative,  that is, (AxB)xC != Ax(BxC) != AxBxC, which is clearer  in lisp syntax:  <code>(product (product A B) C)</code>,  <code>(product A (product B C))</code>,  <code>(product A B C)</code>.  Is this the right choice? </li> <li> For simplicity in this sketch,  I’m starting with a single base set:  all possible Java objects, for short <b>J</b>.  I’m almost certainly missing some issues  because of this, so it needs to be filled in with  something more realistic before this approach can be  considered validated in any sense. </li> <li> Again, for simplicity, all function (co)domains are  the copuntable union of all possible cartesian  product sets built over <b>J</b>.  In other words, all domains and codomains are the  same set, which is a pretty good way to hide problems.  Let’s call this set <b>UJ</b> (better notation?).  Need to add other sets to expose problems resulting  from the assumption that all domains are the same. </li> <li> Elements of <b>UJ</b> will be represented, to begin,  by Clojure sequences, usually <code>vector</code>s.  We need to add other representations ot expose  problems caused this unconscious assumption. </li> <li> Tuple constructors are still multi-arity,  so they aren’t actually functions in the  single domain, codomain sense.  Is there a better way to think about this? </li> <li> Binary operations (associative or not) are common.  Is there a better way to incorporate them into  a conceptual 1-in 1-out conceptual model for cuntions? </li> <li> Multi-arity. multi-multi-value functions  will require possibly countable unions of  cartesian product spaces as (co)domains.  Is there a better way to think about this? </li> <li> Some of the combinators look like map-reduce  transducers. Can we come up with a unified way  to talk about both, maybe better than either? </li> </ul><p></p></div></div><div class="public anchor" id="var-compose"><h3>compose</h3><h4 class="added">added in 2021-04-23</h4><div class="usage"><code>(compose f g)</code></div><div class="doc"><div class="markdown"><p>Returns a named function which evaluates the composition of <code>f</code> and <code>g</code>.</p>
<p><b>TODO:</b> this is a 2-in 1-out function, violating 1-in, 1-out model we are working towards! A variadic arity might fix that?</p>
<p><b>TODO:</b> replace with an implementation of <code>clojure.lang.IFn</code> that lets us get at the <code>factors</code>.</p>
<p><b>TODO:</b> this should be a generic function. </p></div></div><div class="src-link"><a href="https://github.com/palisades-lakes/sicpplus/tree/sicpplus-0.0.0/e:/porta/projects/sicpplus/src/main/clojure/sicpplus/cartesian.clj#L91">view source</a></div></div><div class="public anchor" id="var-diagonal"><h3>diagonal</h3><div class="usage"><code>(diagonal f g)</code></div><div class="doc"><div class="markdown"><p>Take 2 functions and return a function that maps the cartesian product of the domains to the cartesian product of the codomains by applying each function to its corresponding domain element in the input and making a tuple of the 2 results.</p></div></div><div class="src-link"><a href="https://github.com/palisades-lakes/sicpplus/tree/sicpplus-0.0.0/e:/porta/projects/sicpplus/src/main/clojure/sicpplus/cartesian.clj#L182">view source</a></div></div><div class="public anchor" id="var-parallel-diagonal"><h3>parallel-diagonal</h3><div class="usage"><code>(parallel-diagonal h f g)</code></div><div class="doc"><div class="markdown"><p>Like <a href="sicpplus.cartesian.html#var-parallel-split">parallel-split</a>, but assumes <code>(domain h)</code> is the cartesian product of the codomains of <code>f</code> and <code>g</code>, and the domain of the returned function is the cartesian product of the domains of <code>f</code> and <code>g</code>.</p></div></div><div class="src-link"><a href="https://github.com/palisades-lakes/sicpplus/tree/sicpplus-0.0.0/e:/porta/projects/sicpplus/src/main/clojure/sicpplus/cartesian.clj#L197">view source</a></div></div><div class="public anchor" id="var-parallel-split"><h3>parallel-split</h3><div class="usage"><code>(parallel-split h f0 f1)</code></div><div class="doc"><div class="markdown"><p>Compose <code>h</code> with the <a href="sicpplus.cartesian.html#var-split">split</a> of <code>f</code> and <code>g</code>. In other words, return a function that first applies both <code>f0</code> and <code>f1</code> to the input, and then applies <code>h</code> to the output.</p>
<p><b>TODO:</b> figure out a way to avoid constructing a tuple of the values of <code>f0</code> and <code>f1</code>.</p>
<p><b>TODO:</b> figure out a way to avoid constructing a tuple of the values of <code>f0</code> and <code>f1</code>.</p>
<p><b>TODO:</b> better name.</p>
<p><b>TODO:</b> Isn’t this really just a map-reduce transducer where we are mapping over a sequence of functions all applied to the same value?.</p></div></div><div class="src-link"><a href="https://github.com/palisades-lakes/sicpplus/tree/sicpplus-0.0.0/e:/porta/projects/sicpplus/src/main/clojure/sicpplus/cartesian.clj#L159">view source</a></div></div><div class="public anchor" id="var-projection"><h3>projection</h3><div class="usage"><code>(projection i)</code></div><div class="doc"><div class="markdown"><p>Return the projection that selects the <code>i</code>th element of a cartesian tuple.</p>
<p><b>TODO:</b> handle <code>int</code> indexes, and any reasonable index set.</p>
<p><b>TODO:</b> Memoize? So we don’t need the instances below?</p></div></div><div class="src-link"><a href="https://github.com/palisades-lakes/sicpplus/tree/sicpplus-0.0.0/e:/porta/projects/sicpplus/src/main/clojure/sicpplus/cartesian.clj#L131">view source</a></div></div><div class="public anchor" id="var-split"><h3>split</h3><div class="usage"><code>(split f g)</code></div><div class="doc"><div class="markdown"><p>Take 2 functions with the same domain and return a function that maps that to the cartesian product of the codomains by applying both function to the input and making a tuple of the 2 results.</p>
<p><b>TODO:</b> better name.</p></div></div><div class="src-link"><a href="https://github.com/palisades-lakes/sicpplus/tree/sicpplus-0.0.0/e:/porta/projects/sicpplus/src/main/clojure/sicpplus/cartesian.clj#L145">view source</a></div></div><div class="public anchor" id="var-tuple"><h3>tuple</h3><div class="usage"><code>(tuple &amp; elements)</code></div><div class="doc"><div class="markdown"><p>Collect the <code>elements</code> into a cartesian tuple. Note that any given tuple may be an element of many cartesian product sets. Here just using <code>vector</code> for all tuples, supporting only the set of all possible Java objects as the element domains.</p>
<p><b>TODO:</b> generalize to key-value structure with any reasonable index set.</p></div></div><div class="src-link"><a href="https://github.com/palisades-lakes/sicpplus/tree/sicpplus-0.0.0/e:/porta/projects/sicpplus/src/main/clojure/sicpplus/cartesian.clj#L112">view source</a></div></div></div></body></html>